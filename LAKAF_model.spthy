theory LAKAF_Model
begin

builtins: hashing, symmetric-encryption, xor, bilinear-pairing


rule TA_Init:
    let 
        pub_key = pmult(~ltk,'g')
    in
    [Fr(~ltk)]
    --[TA_init($TA),OnlyOnce('TA_init')]->
    [!Ltk_TA($TA, ~ltk), !Pk_TA($A,  pub_key), Out(pub_key) ]

//User Registration Phase Rule(with TA)
rule User_Registration:
    let 
        g_U = h(<~PW,~fp_U>) XOR ~r_U
        A = h(<~ID_U,~ltk,~C_U>)
        beta = A XOR g_U
        beta1 = beta XOR ~fp_U
        beta2 = h(<~ID_U,~PW,beta1>)
    in
    [Fr(~PW),Fr(~r_U),Fr(~fp_U),Fr(~ID_U),Fr(~C_U),
    !Ltk_TA($TA, ~ltk)] 
    --[
    User_Reg_done($U),
    Privacy(~ID_U),
    OnlyOnce('User_init')
    ]->
    [!User_state($U,~fp_U,~PW,beta,beta1,beta2,~C_U),
    !User_ID($U,~ID_U)]


// Server Registration Phase Rule(with TA)
rule Server_Registration:
    let 
        public_key = pmult(~r_S,'g')
        V = h(<~ID_S,~ltk,~C_S>)
    in
    [Fr(~ID_S),Fr(~r_S),Fr(~C_S),
    !Ltk_TA($TA, ~ltk)] 
    --[Server_Reg_done($S),OnlyOnce('Server_init')]-> 
    [
    !Server_state($S,~r_S,V,~C_S),
    !Server_public($S,public_key),
    !Server_ID($S,~ID_S),
    Out(public_key)
    ]

//Login Auth and Key Agreement
// step a(Login)
rule user_login_request:
    let
        B1 = beta XOR ~fp_U
        B2 = h(<ID_U,~PW,B1>)
        S1 = h(<ID_U,~a,~C_U>)
        I1 = ID_U XOR h(~t1) XOR ~t1
        K1 = h(<ID_U,h(~t1 XOR public_key),~t1>)
        E1 = senc(<~a,S1,~C_U>,K1)
        m4 = <E1,I1,~t1>
    in
    [!User_state($U,~fp_U,~PW,beta,beta1,beta2,~C_U),
    !User_ID($U,ID_U),
    !Server_public($S,public_key),
    Fr(~a),
    Fr(~t1)] 
    --[
    Secret1(K1),
    Eq(beta2,B2),
    OnlyOnce('U_login'),
    User_Initiate($U,$S,<K1,E1>)
    ]->
    [
    Out(m4),
    !User_state_2($U,S1,~a,K1,~t1)]
    

rule server_recv_request:
    let 
        I2 = I1 XOR h(~t1) XOR ~t1
        K2 = h(<I2,h(~t1 XOR pmult(~r_S,'g')),~t1>)
        SK_S = h(<ID_U,ID_S,~C_U,~C_S,pmult(~a,pmult(~b,'g')),~t3>)
        S2 = h(<ID_S,ID_U,S1,V,SK_S,~t1>)
        V1 = V XOR h(<~C_U,ID_U,K2>)
        N = ID_S XOR h(<~b,~C_S,~C_U>)
        K3 = h(<ID_U,S1,~a,~C_U,~t3>)
        E2 = senc(<N,V1,S2,~C_S,~b>,K3)
        M5 = <E2,~t3>
    in 
    [
    In(<senc(<~a,S1,~C_U>,K2),I1,~t1>),
    !User_ID($U,ID_U),
    !Server_state($S,~r_S,V,~C_S),
    !Server_ID($S,ID_S),
    Fr(~b),
    Fr(~t3)
    ]
    --[
    Eq(I2,ID_U),
    Eq(S1,h(<ID_U,~a,~C_U>)),
    Secret2(K3),
    Server_recv($U,$S,<K2,senc(<~a,S1,~C_U>,K2)>),
    Server_send($U,$S,<K3,E2>),
    Secret_SK_S(SK_S),
    Server_User_Agreement($S,$U,SK_S),
    OnlyOnce('Server_Receive')
    ]->
    [Out(M5)]

rule user_server_agreement:
    let 
        K4 = h(<ID_U,S1,~a,~C_U,~t3>)
        SK_U = h(<ID_U,ID_S,~C_U,~C_S,pmult(~b,pmult(~a,'g')),~t3>)
        V_Star = V1 XOR h(<~C_U,ID_U,K1>)
    in
    [
    In(<senc(<N,V1,S2,~C_S,~b>,K4),~t3>),
    !User_state($U,~fp_U,~PW,beta,beta1,beta2,~C_U),
    !User_ID($U,ID_U),
    !Server_ID($S,ID_S),
    !User_state_2($U,S1,~a,K1,~t1)
    ]
    --[
    Eq(ID_S,N XOR h(<~b,~C_S,~C_U>)),
    Eq(S2,h(<ID_S,ID_U,S1,V_Star,SK_U,~t1>)),
    Secret_SK_U(SK_U),
    User_Server_Agreement($S,$U,SK_U),
    User_recv($U,$S,<K4,senc(<N,V1,S2,~C_S,~b>,K4)>),
    OnlyOnce('User_Receive')
    ]->
    []


//************************************************************
// Restriction Lemmas
//************************************************************
//Equality Restriction
restriction Equality:
    "All x y #i . Eq(x,y) @#i ==> x=y"

//Only Once Restriction
restriction OnlyOnce:
	"
	All x #i #j . OnlyOnce(x) @ i & OnlyOnce(x) @ j ==> #i = #j
	"
//*************************************************************

//************************************************************
// Protocol Executability Check Lemmas
//************************************************************

lemma key_agreement_possible_check:
    exists-trace
    "Ex S U SK #i #j #k #l . User_Reg_done(U)@#i & Server_Reg_done(S)@#j & Server_User_Agreement(S,U,SK)@ k & User_Server_Agreement(S,U,SK)@ l"


//*************************************************************

//************************************************************
// Secrecy Lemmas
//************************************************************

lemma user_anonymity: //user anonymity
    "(All ID_U U S #i1 #i2 #i3 . Privacy(ID_U) @i1 &
    User_Reg_done(U) @i2 &
    Server_Reg_done(S) @i3
     ==>
    (not Ex #j. K(ID_U)@#j))"


//Temporary key K1 generated by user
lemma k1_secrecy:
    "(All M K1 U S #i1 #i2 #i3 #i4 #i5. Secret1(K1) @i1 &
    User_Reg_done(U) @i2 &
    Server_Reg_done(S) @i3 &
    User_Initiate(U,S,<K1,M>) @i4 &
    Server_recv(U,S,<K1,M>)@i5
     ==>
    (not Ex #j. K(K1)@#j))"


//Temporary key K3 generated by SP
lemma k3_secrecy:
    "(All M K3 U S #i1 #i2 #i3 #i4 #i5. Secret2(K3) @i1 &
    User_Reg_done(U) @i2 &
    Server_Reg_done(S) @i3 &
    Server_send(U,S,<K3,M>) @i4 &
    User_recv(U,S,<K3,M>)@i5
    ==>
    (not Ex #j. K(K3)@#j))"

//shared session key secrecy
lemma sk_secrecy:
       "(All SK_U U S M #i1 #i2 #i3 #i4 #i5 #i6 #i7. Secret_SK_U(SK_U) @i1 &
   User_Reg_done(U) @i2 &
   Server_Reg_done(S) @i3 &
   User_Initiate(U,S,M) @i4 &
   Server_recv(U,S,M) @i5 &
   Server_User_Agreement(S,U,SK_U) @i6 &
   User_Server_Agreement(S,U,SK_U) @i7
   ==>
   (not Ex #j. K(SK_U)@#j))"
//*************************************************************
end